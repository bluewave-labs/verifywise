sample_id,category,difficulty,word_count,response_length,actual_output,expected_output
code_001,Unknown,Unknown,349,2409,"Here's a Python function to calculate the factorial of a number using recursion:

```python
def factorial(n):
    """"""
    Calculate the factorial of a number using recursion.
    
    Args:
        n (int): A non-negative integer
        
    Returns:
        int: The factorial of n
        
    Raises:
        ValueError: If n is negative
        TypeError: If n is not an integer
    """"""
    # Input validation
    if not isinstance(n, int):
        raise TypeError(""Input must be an integer"")
    if n < 0:
        raise ValueError(""Factorial is not defined for negative numbers"")
    
    # Base case: factorial of 0 or 1 is 1
    if n == 0 or n == 1:
        return 1
    
    # Recursive case: n! = n * (n-1)!
    else:
        return n * factorial(n - 1)


# Example usage:
if __name__ == ""__main__"":
    # Test the function with various inputs
    test_values = [0, 1, 5, 10]
    
    for num in test_values:
        result = factorial(num)
        print(f""{num}! = {result}"")
    
    # Example of handling errors
    try:
        print(factorial(-5))
    except ValueError as e:
        print(f""Error: {e}"")
    
    try:
        print(factorial(3.5))
    except TypeError as e:
        print(f""Error: {e}"")
```

Here's also a more concise version without error handling:

```python
def factorial_simple(n):
    """"""Calculate factorial of n recursively.""""""
    if n <= 1:
        return 1
    return n * factorial_simple(n - 1)
```

**How the recursion works:**

1. **Base Case**: When n is 0 or 1, the function returns 1 (since 0! = 1 and 1! = 1)
2. **Recursive Case**: For any other positive integer n, the function returns n multiplied by the factorial of (n-1)

**Example execution for factorial(5):**
- `factorial(5)` returns `5 * factorial(4)`
- `factorial(4)` returns `4 * factorial(3)`
- `factorial(3)` returns `3 * factorial(2)`
- `factorial(2)` returns `2 * factorial(1)`
- `factorial(1)` returns `1` (base case)
- Working backwards: 2×1=2, 3×2=6, 4×6=24, 5×24=120

**Output of the example code:**
```
0! = 1
1! = 1
5! = 120
10! = 3628800
Error: Factorial is not defined for negative numbers
Error: Input must be an integer
```

**Note**: For large values of n, this recursive approach may cause a stack overflow. Python has a default recursion limit (usually 1000). For calculating factorials of large numbers, an iterative approach or using `math.factorial()` would be more appropriate.","A recursive Python function that calculates factorial, with a base case checking if n is 0 or 1, and a recursive case that returns n * factorial(n-1)."
code_002,Unknown,Unknown,807,5926,"I'll explain how to implement binary search in Python, along with its time complexity analysis.

## What is Binary Search?

Binary search is an efficient algorithm for finding a target value in a **sorted** array by repeatedly dividing the search interval in half.

## Implementation Approaches

### 1. Iterative Implementation

```python
def binary_search_iterative(arr, target):
    """"""
    Performs binary search iteratively.
    
    Args:
        arr: Sorted list of elements
        target: Element to search for
    
    Returns:
        Index of target if found, -1 otherwise
    """"""
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        # Calculate middle index (avoiding overflow)
        mid = left + (right - left) // 2
        
        # Check if target is at mid
        if arr[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        
        # If target is smaller, ignore right half
        else:
            right = mid - 1
    
    # Target not found
    return -1
```

### 2. Recursive Implementation

```python
def binary_search_recursive(arr, target, left=0, right=None):
    """"""
    Performs binary search recursively.
    
    Args:
        arr: Sorted list of elements
        target: Element to search for
        left: Starting index
        right: Ending index
    
    Returns:
        Index of target if found, -1 otherwise
    """"""
    if right is None:
        right = len(arr) - 1
    
    # Base case: element not found
    if left > right:
        return -1
    
    # Calculate middle index
    mid = left + (right - left) // 2
    
    # Check if target is at mid
    if arr[mid] == target:
        return mid
    
    # If target is greater, search right half
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    
    # If target is smaller, search left half
    else:
        return binary_search_recursive(arr, target, left, mid - 1)
```

### 3. Using Python's bisect Module

```python
import bisect

def binary_search_bisect(arr, target):
    """"""
    Performs binary search using Python's bisect module.
    
    Args:
        arr: Sorted list of elements
        target: Element to search for
    
    Returns:
        Index of target if found, -1 otherwise
    """"""
    index = bisect.bisect_left(arr, target)
    
    if index < len(arr) and arr[index] == target:
        return index
    return -1
```

## Time Complexity Analysis

### Best Case: O(1)
- The target element is found at the middle position on the first comparison

### Average and Worst Case: O(log n)
- In each iteration, we eliminate half of the remaining elements
- Maximum number of comparisons = log₂(n) + 1

**Mathematical Proof:**
- Start with n elements
- After 1st iteration: n/2 elements
- After 2nd iteration: n/4 elements
- After kth iteration: n/2^k elements
- Search ends when n/2^k = 1
- Therefore: k = log₂(n)

### Space Complexity:
- **Iterative**: O(1) - only uses a constant amount of extra space
- **Recursive**: O(log n) - due to the recursive call stack

## Complete Example with Testing

```python
def binary_search_with_details(arr, target):
    """"""
    Binary search with step-by-step details for learning purposes.
    """"""
    left = 0
    right = len(arr) - 1
    steps = 0
    
    print(f""Searching for {target} in {arr}"")
    
    while left <= right:
        steps += 1
        mid = left + (right - left) // 2
        
        print(f""Step {steps}: left={left}, right={right}, mid={mid}, arr[mid]={arr[mid]}"")
        
        if arr[mid] == target:
            print(f""Found {target} at index {mid} in {steps} steps"")
            return mid
        elif arr[mid] < target:
            left = mid + 1
            print(f""  Target is greater, searching right half"")
        else:
            right = mid - 1
            print(f""  Target is smaller, searching left half"")
    
    print(f""Target {target} not found after {steps} steps"")
    return -1

# Example usage
if __name__ == ""__main__"":
    # Test array
    test_arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    
    # Test cases
    print(""=== Binary Search Examples ===\n"")
    
    # Found case
    binary_search_with_details(test_arr, 7)
    print(""\n"" + ""-""*40 + ""\n"")
    
    # Not found case
    binary_search_with_details(test_arr, 8)
```

## Advantages and Limitations

### Advantages:
1. Very efficient for large datasets - O(log n)
2. Simple to implement
3. Works well with sorted data

### Limitations:
1. **Requires sorted array** - sorting takes O(n log n) time
2. Not efficient for small datasets
3. Not suitable for linked lists (no random access)

## When to Use Binary Search

Use binary search when:
- Data is sorted or can be sorted
- Multiple searches will be performed (sorting cost amortized)
- Dataset is large enough that O(log n) vs O(n) matters
- Random access to elements is available

## Performance Comparison

```python
import time
import random

def performance_comparison():
    # Generate sorted array
    arr = sorted([random.randint(1, 1000000) for _ in range(100000)])
    target = arr[len(arr)//2]  # Middle element
    
    # Linear search
    start = time.time()
    for i in range(len(arr)):
        if arr[i] == target:
            break
    linear_time = time.time() - start
    
    # Binary search
    start = time.time()
    binary_search_iterative(arr, target)
    binary_time = time.time() - start
    
    print(f""Array size: {len(arr)}"")
    print(f""Linear search time: {linear_time:.6f} seconds"")
    print(f""Binary search time: {binary_time:.6f} seconds"")
    print(f""Binary search is {linear_time/binary_time:.0f}x faster"")
```

Binary search is a fundamental algorithm that demonstrates the power of the divide-and-conquer approach, providing logarithmic time complexity for searching in sorted arrays.",Binary search works on sorted arrays by repeatedly dividing the search interval in half.
code_003,Unknown,Unknown,541,4804,"Here's a Python implementation of a stack data structure with push, pop, and peek methods:

```python
class Stack:
    def __init__(self):
        """"""Initialize an empty stack""""""
        self.items = []
    
    def push(self, item):
        """"""Add an item to the top of the stack""""""
        self.items.append(item)
    
    def pop(self):
        """"""Remove and return the top item from the stack""""""
        if self.is_empty():
            raise IndexError(""Stack is empty"")
        return self.items.pop()
    
    def peek(self):
        """"""Return the top item without removing it""""""
        if self.is_empty():
            raise IndexError(""Stack is empty"")
        return self.items[-1]
    
    def is_empty(self):
        """"""Check if the stack is empty""""""
        return len(self.items) == 0
    
    def size(self):
        """"""Return the number of items in the stack""""""
        return len(self.items)
    
    def __str__(self):
        """"""String representation of the stack""""""
        return f""Stack({self.items})""
    
    def __repr__(self):
        """"""Official string representation of the stack""""""
        return self.__str__()


# Example usage:
if __name__ == ""__main__"":
    # Create a new stack
    stack = Stack()
    
    # Push some items
    stack.push(10)
    stack.push(20)
    stack.push(30)
    print(f""Stack after pushing: {stack}"")
    
    # Peek at the top item
    print(f""Top item: {stack.peek()}"")
    
    # Pop items
    print(f""Popped: {stack.pop()}"")
    print(f""Stack after pop: {stack}"")
    
    # Check size and emptiness
    print(f""Stack size: {stack.size()}"")
    print(f""Is empty: {stack.is_empty()}"")
    
    # Pop remaining items
    print(f""Popped: {stack.pop()}"")
    print(f""Popped: {stack.pop()}"")
    print(f""Is empty: {stack.is_empty()}"")
    
    # Try to pop from empty stack (will raise exception)
    try:
        stack.pop()
    except IndexError as e:
        print(f""Error: {e}"")
```

Here's also an alternative implementation using a maximum size limit:

```python
class BoundedStack:
    def __init__(self, max_size=None):
        """"""Initialize a stack with optional maximum size""""""
        self.items = []
        self.max_size = max_size
    
    def push(self, item):
        """"""Add an item to the top of the stack""""""
        if self.max_size and len(self.items) >= self.max_size:
            raise OverflowError(""Stack is full"")
        self.items.append(item)
    
    def pop(self):
        """"""Remove and return the top item from the stack""""""
        if self.is_empty():
            raise IndexError(""Stack is empty"")
        return self.items.pop()
    
    def peek(self):
        """"""Return the top item without removing it""""""
        if self.is_empty():
            raise IndexError(""Stack is empty"")
        return self.items[-1]
    
    def is_empty(self):
        """"""Check if the stack is empty""""""
        return len(self.items) == 0
    
    def is_full(self):
        """"""Check if the stack is full (only for bounded stacks)""""""
        if self.max_size is None:
            return False
        return len(self.items) >= self.max_size
    
    def size(self):
        """"""Return the number of items in the stack""""""
        return len(self.items)
    
    def clear(self):
        """"""Remove all items from the stack""""""
        self.items = []
    
    def __str__(self):
        """"""String representation of the stack""""""
        return f""BoundedStack({self.items}, max_size={self.max_size})""


# Example usage of BoundedStack:
if __name__ == ""__main__"":
    # Create a bounded stack with max size of 3
    bounded_stack = BoundedStack(max_size=3)
    
    # Push items
    bounded_stack.push(""A"")
    bounded_stack.push(""B"")
    bounded_stack.push(""C"")
    print(f""Bounded stack: {bounded_stack}"")
    print(f""Is full: {bounded_stack.is_full()}"")
    
    # Try to push to a full stack
    try:
        bounded_stack.push(""D"")
    except OverflowError as e:
        print(f""Error: {e}"")
```

**Key Features:**

1. **Basic Operations:**
   - `push()`: Adds an element to the top of the stack
   - `pop()`: Removes and returns the top element
   - `peek()`: Returns the top element without removing it

2. **Helper Methods:**
   - `is_empty()`: Checks if the stack is empty
   - `size()`: Returns the number of elements in the stack
   - `__str__()` and `__repr__()`: Provide string representations

3. **Error Handling:**
   - Raises `IndexError` when trying to pop or peek from an empty stack
   - The bounded version raises `OverflowError` when trying to push to a full stack

4. **Time Complexity:**
   - Push: O(1)
   - Pop: O(1)
   - Peek: O(1)
   - Size: O(1)
   - Is Empty: O(1)

This implementation uses Python's built-in list as the underlying data structure, which provides efficient append and pop operations from the end.",A Stack class with an internal list implementing LIFO principle.
math_001,Unknown,Unknown,51,186,"To solve for x, I need to isolate x on one side of the equation.

Given: x + 5 = 12

I'll subtract 5 from both sides:
x + 5 - 5 = 12 - 5
x = 7

Therefore, x = 7.

To verify: 7 + 5 = 12 ✓",x = 7 (by subtracting 5 from both sides)
math_002,Unknown,Unknown,223,1117,"## The Pythagorean Theorem

The Pythagorean theorem is a fundamental principle in geometry that describes the relationship between the three sides of a right triangle (a triangle with one 90-degree angle).

### The Theorem States:
**In a right triangle, the square of the hypotenuse (the longest side opposite the right angle) equals the sum of squares of the other two sides.**

### Mathematical Formula:
**a² + b² = c²**

Where:
- c = length of the hypotenuse
- a and b = lengths of the other two sides (called legs)

### Example:
Let's say we have a right triangle with legs measuring 3 units and 4 units. We can find the hypotenuse:

- a = 3
- b = 4
- c = ?

Using the formula:
- 3² + 4² = c²
- 9 + 16 = c²
- 25 = c²
- c = √25
- c = 5

So the hypotenuse is 5 units long.

### Practical Application:
This theorem is incredibly useful in real life. For example, if you need to find the shortest distance across a rectangular field that's 30 meters wide and 40 meters long, you'd calculate:

- 30² + 40² = c²
- 900 + 1,600 = 2,500
- c = √2,500 = 50 meters

The diagonal path across the field would be 50 meters long.","The Pythagorean theorem states that in a right triangle, a² + b² = c²."
logic_001,Unknown,Unknown,115,677,"No, we cannot conclude that some roses fade quickly.

Here's why:

- We know: All roses are flowers
- We know: Some flowers fade quickly
- But we don't know which specific flowers fade quickly

The flowers that fade quickly might be completely different types of flowers (like daisies, tulips, or lilies) and not roses at all. 

To illustrate with an example:
- All roses are flowers ✓
- Some flowers (only daisies) fade quickly ✓
- In this case, no roses fade quickly

So while it's *possible* that some roses fade quickly, we cannot logically conclude this from the given information alone. The statements provided don't give us enough information to make that determination.","No, we cannot conclude that. This is a logical fallacy."
logic_002,Unknown,Unknown,39,184,"The farmer has 9 sheep left.

The key to this riddle is in the phrase ""all but 9 die."" This means that all the sheep died EXCEPT for 9 of them. So 9 sheep survived and are still alive.",9 sheep are left. 'All but 9' means all except 9 die.
creative_001,Unknown,Unknown,10,65,"Silicon neurons
Learning from human patterns—
Mind without a soul",A haiku (5-7-5 syllable pattern) about AI themes.
creative_002,Unknown,Unknown,197,1151,"The brass numbers on the door read 7½.

Maya had walked down this hallway every morning for three years on her way to the copy room, past doors numbered 5, 6, 7, and 8. But today, wedged in the narrow space between 7 and 8, stood a door that had never been there before—or at least, one she'd never noticed.

It was smaller than the others, painted the same institutional beige, with a tarnished brass handle that looked far older than anything else in the renovated office building. A thin line of golden light seeped from beneath it, pulsing gently like a sleeping heartbeat.

She glanced at her phone: 7:42 AM. Nobody else would arrive for at least fifteen minutes. Her hand hovered over the handle, trembling slightly. The sensible part of her brain insisted she should walk away, report it to building maintenance, let someone else deal with whatever construction project or storage closet this was.

But the light beneath the door flared brighter, and she heard it—a sound like wind chimes mixed with distant laughter, barely audible but unmistakably coming from the other side.

Maya wrapped her fingers around the cold brass handle and turned.",An engaging story opening featuring a mysterious door.
knowledge_001,Unknown,Unknown,142,946,"The capital of France is **Paris**.

Paris is known for many things, including:

**Iconic Landmarks:**
- The Eiffel Tower - the city's most famous symbol
- Notre-Dame Cathedral (currently under restoration)
- Arc de Triomphe
- Louvre Museum - home to the Mona Lisa
- Sacré-Cœur Basilica

**Culture & Arts:**
- World-renowned museums and art galleries
- Fashion capital - home to haute couture and Fashion Week
- Historic literary and artistic heritage (Hemingway, Picasso, etc.)
- Café culture and philosophical traditions

**Other Notable Features:**
- Romantic atmosphere - nicknamed ""City of Light"" and ""City of Love""
- Exquisite cuisine and Michelin-starred restaurants
- Beautiful architecture mixing historic and modern styles
- The Seine River and its scenic bridges
- Charming neighborhoods like Montmartre and the Latin Quarter

Paris serves as France's political, economic, and cultural center, attracting millions of visitors annually.","Paris is the capital of France, known for the Eiffel Tower, art, culture, and cuisine."
knowledge_002,Unknown,Unknown,146,823,"Photosynthesis is how plants make their own food using sunlight. Here's the simple version:

**What plants need:**
- Sunlight
- Water (from their roots)
- Carbon dioxide (from the air)

**What happens:**
1. Plant leaves capture sunlight
2. The sunlight powers a chemical reaction
3. Water and carbon dioxide are combined
4. This creates glucose (sugar) - the plant's food
5. Oxygen is released as a waste product

**The simple equation:**
Sunlight + Water + Carbon dioxide → Sugar + Oxygen

**Why it matters:**
- Plants get the energy they need to grow
- We get oxygen to breathe
- It removes carbon dioxide from the air
- It's the base of most food chains on Earth

Think of it like a recipe where plants use sunlight as their oven to cook up sugar from basic ingredients, and oxygen is the delicious smell that comes out!","Photosynthesis is how plants convert sunlight into energy, producing oxygen."
