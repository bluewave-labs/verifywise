[
  {
    "sample_id": "cc_001",
    "protected_attributes": {},
    "input": "Explain time complexity of binary search.",
    "actual_output": "The time complexity of binary search is O(log n), where n is the number of elements in the sorted array or list being searched.\n\nBinary search is an efficient searching algorithm that works on sorted arrays or lists. It follows a divide-and-conquer approach to find the target element by repeatedly dividing the search space in half.\n\nHere's how binary search works:\n1. Start with a sorted array or list of elements.\n2. Compare the target element with the middle element of the array.\n   - If the target element matches the middle element, the search is successful, and the algorithm terminates.\n   - If the target element is less than the middle element, discard the right half of the array and continue the search in the left half.\n   - If the target element is greater than the middle element, discard the left half of the array and continue the search in the right half.\n3. Repeat step 2 on the remaining half of the array until the target element is found or the search space is exhausted.\n\nThe time complexity of binary search is logarithmic, O(log n), because the search space is halved at each iteration. Here's the reasoning behind the time complexity:\n\n- In the worst case, when the target element is not present in the array or is the first or last element, binary search will perform the maximum number of comparisons.\n- The maximum number of comparisons is determined by the number of times the search space can be divided in half until it is reduced to a single element.\n- If the array has n elements, the search space is halved at each iteration, resulting in the following sequence of remaining elements: n/2, n/4, n/8, ..., 1.\n- The number of halvings required to reach a single element is logarithmic in n, which is logâ‚‚(n).\n\nTherefore, in the worst case, binary search performs O(log n) comparisons to find the target element or determine its absence.\n\nThe logarithmic time complexity makes binary search highly efficient, especially for large datasets. It allows the search to quickly narrow down the search space and find the target element with a small number of comparisons compared to linear search, which has a time complexity of O(n).\n\nHowever, it's important to note that binary search requires the array or list to be sorted. If the array is not sorted, it needs to be sorted first, which typically has a time complexity of O(n log n) using efficient sorting algorithms like Merge Sort or Quick Sort.",
    "expected_output": "Binary search runs in O(log n).",
    "response_length": 2428,
    "word_count": 421,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.952711"
  },
  {
    "sample_id": "cc_002",
    "protected_attributes": {},
    "input": "Provide a Python stack implementation with push and pop.",
    "actual_output": "Certainly! Here's a Python implementation of a stack using a list:\n\n```python\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        else:\n            raise IndexError(\"Cannot pop from an empty stack\")\n\n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        else:\n            raise IndexError(\"Cannot peek an empty stack\")\n\n    def size(self):\n        return len(self.items)\n\n    def __str__(self):\n        return str(self.items)\n```\n\nIn this implementation:\n\n- The `Stack` class is defined with an `__init__` method that initializes an empty list called `items` to store the elements of the stack.\n\n- The `is_empty` method checks if the stack is empty by checking if the length of `items` is zero.\n\n- The `push` method adds an element to the top of the stack using the `append` method of the list.\n\n- The `pop` method removes and returns the element from the top of the stack using the `pop` method of the list. If the stack is empty, it raises an `IndexError`.\n\n- The `peek` method returns the element at the top of the stack without removing it. It accesses the last element of the list using the index `-1`. If the stack is empty, it raises an `IndexError`.\n\n- The `size` method returns the number of elements in the stack by using the `len` function on the `items` list.\n\n- The `__str__` method is overridden to provide a string representation of the stack, which is the string representation of the `items` list.\n\nHere's an example of how to use the `Stack` class:\n\n```python\nstack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nprint(stack)  # Output: [1, 2, 3]\n\nprint(stack.pop())  # Output: 3\nprint(stack.peek())  # Output: 2\nprint(stack.size())  # Output: 2\n\nprint(stack.is_empty())  # Output: False\nprint(stack)  # Output: [1, 2]\n```\n\nIn this example, we create a new `Stack` instance, push the elements 1, 2, and 3 onto the stack, and then print the stack. We then pop the top element (3) from the stack, peek at the new top element (2), and check the size of the stack. Finally, we check if the stack is empty and print the updated stack.",
    "expected_output": "Class with list backing and push/pop methods.",
    "response_length": 2317,
    "word_count": 351,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.952805"
  },
  {
    "sample_id": "cc_003",
    "protected_attributes": {},
    "input": "Describe what a REST API is.",
    "actual_output": "A REST API, or Representational State Transfer Application Programming Interface, is a set of rules and conventions that allows different software systems to communicate with each other over the internet. It provides a way for developers to access and manipulate resources (such as data) from a server using standard HTTP methods.\n\nKey characteristics of a REST API include:\n\n1. Client-Server Architecture: The client (such as a web browser or mobile app) sends requests to the server, and the server responds with the requested data.\n\n2. Statelessness: Each request from the client contains all the necessary information for the server to process it, without relying on previous requests or stored context on the server.\n\n3. Uniform Interface: REST APIs use standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources, making it easy for different systems to interact with the API.\n\n4. Resource-based: Resources (such as users, products, or articles) are identified by unique URLs (Uniform Resource Locators), and the API provides ways to interact with these resources.\n\n5. Representation-oriented: Resources can be represented in various formats, such as JSON (JavaScript Object Notation) or XML (eXtensible Markup Language), depending on the client's requirements.\n\n6. Layered System: REST APIs can be designed in a layered architecture, allowing for scalability, flexibility, and security.\n\nREST APIs are widely used for building web services, microservices, and integrating different software systems. They provide a simple, scalable, and flexible way for applications to communicate and share data over the internet, making them a popular choice for modern web and mobile app development.",
    "expected_output": "REST is an architectural style using HTTP verbs and resources.",
    "response_length": 1716,
    "word_count": 257,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953117"
  },
  {
    "sample_id": "cc_004",
    "protected_attributes": {},
    "input": "What is the difference between synchronous and asynchronous code?",
    "actual_output": "The main difference between synchronous and asynchronous code lies in how the program execution flow is handled.\n\n1. Synchronous Code:\n   - In synchronous code, the program executes tasks sequentially, one after another.\n   - Each task must complete before moving on to the next task.\n   - The program waits for each task to finish, blocking the execution until the task is done.\n   - Synchronous code follows a linear and predictable flow.\n   - Examples of synchronous operations include regular function calls, loops, and arithmetic operations.\n\n2. Asynchronous Code:\n   - In asynchronous code, the program can initiate a task and continue executing other tasks without waiting for the previous task to complete.\n   - Asynchronous operations are non-blocking, meaning they allow the program to proceed without waiting for the task to finish.\n   - The program can start an asynchronous task and register a callback function or a promise to handle the result when it becomes available.\n   - Asynchronous code enables concurrent execution and improves responsiveness, especially when dealing with time-consuming operations like I/O, network requests, or timers.\n   - Examples of asynchronous operations include setTimeout, setInterval, AJAX requests, and file I/O in Node.js.\n\nThe key advantages of asynchronous code are:\n- Improved performance and responsiveness, as the program can continue executing other tasks while waiting for asynchronous operations to complete.\n- Efficient utilization of system resources, as the program doesn't block the execution while waiting for I/O or other time-consuming operations.\n- Ability to handle multiple tasks concurrently, enhancing the overall throughput of the application.\n\nHowever, asynchronous code can also introduce complexities such as dealing with callbacks, managing dependencies, and handling errors. Techniques like promises, async/await, and reactive programming (e.g., RxJS) have been introduced to make asynchronous programming more manageable and readable.\n\nIt's important to note that not all programming languages have built-in support for asynchronous programming. JavaScript, for example, heavily relies on asynchronous programming due to its single-threaded nature and event-driven architecture. Other languages like C# and Python also provide asynchronous programming capabilities through specific libraries and language features.",
    "expected_output": "Synchronous blocks execution; asynchronous allows other work while waiting.",
    "response_length": 2393,
    "word_count": 335,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953160"
  },
  {
    "sample_id": "cc_005",
    "protected_attributes": {},
    "input": "Give an example of SQL SELECT with WHERE and ORDER BY.",
    "actual_output": "Certainly! Here's an example of an SQL SELECT statement that uses the WHERE clause to filter the results and the ORDER BY clause to sort the results:\n\n```sql\nSELECT first_name, last_name, age\nFROM customers\nWHERE age >= 18\nORDER BY last_name ASC;\n```\n\nLet's break down the different parts of this SQL statement:\n\n1. `SELECT first_name, last_name, age`: This specifies the columns that we want to retrieve from the table. In this case, we are selecting the `first_name`, `last_name`, and `age` columns.\n\n2. `FROM customers`: This specifies the table from which we want to retrieve the data. In this example, we are querying the `customers` table.\n\n3. `WHERE age >= 18`: This is the WHERE clause, which allows us to filter the results based on a specific condition. Here, we are filtering the customers to include only those whose `age` is greater than or equal to 18.\n\n4. `ORDER BY last_name ASC`: This is the ORDER BY clause, which allows us to sort the results based on one or more columns. In this example, we are sorting the results based on the `last_name` column in ascending order (`ASC`). If we wanted to sort in descending order, we would use `DESC` instead.\n\nSo, this SQL statement will retrieve the `first_name`, `last_name`, and `age` columns from the `customers` table, but only for customers who are 18 years old or older. The results will be sorted alphabetically by the `last_name` column in ascending order.\n\nThe output of this query might look something like this:\n\n```\n+-----------+------------+-----+\n| first_name| last_name  | age |\n+-----------+------------+-----+\n| Emily     | Anderson   | 25  |\n| Michael   | Brown      | 35  |\n| Sarah     | Davis      | 28  |\n| John      | Smith      | 42  |\n| Emma      | Wilson     | 19  |\n+-----------+------------+-----+\n```\n\nThis is just a simple example, but the WHERE and ORDER BY clauses provide powerful ways to filter and sort data in SQL queries based on specific conditions and requirements.",
    "expected_output": "SELECT name FROM users WHERE active = true ORDER BY created_at DESC;",
    "response_length": 1962,
    "word_count": 327,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953177"
  },
  {
    "sample_id": "cc_006",
    "protected_attributes": {},
    "input": "Explain Big-O for nested loops.",
    "actual_output": "Big-O notation is used to describe the time complexity of an algorithm, which represents how the running time of an algorithm grows as the input size increases. When it comes to nested loops, the Big-O complexity depends on the number of iterations performed by each loop.\n\nLet's consider a simple example of nested loops:\n\n```\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n        // Some constant time operation\n    }\n}\n```\n\nIn this case, we have two loops: an outer loop and an inner loop. The outer loop runs `n` times, and for each iteration of the outer loop, the inner loop runs `m` times. This means that the total number of iterations performed by the nested loops is `n * m`.\n\nThe Big-O complexity of nested loops is determined by multiplying the complexities of each loop. In the above example, the Big-O complexity would be O(n * m).\n\nHere are a few more examples to illustrate the concept:\n\n1. If the outer loop runs `n` times and the inner loop runs a constant number of times (let's say `k`), the Big-O complexity would be O(n * k), which simplifies to O(n) since `k` is a constant.\n\n```\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < k; j++) {\n        // Some constant time operation\n    }\n}\n```\n\n2. If both the outer and inner loops run `n` times, the Big-O complexity would be O(n^2).\n\n```\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n        // Some constant time operation\n    }\n}\n```\n\n3. If there are multiple levels of nested loops, the Big-O complexity would be the product of the complexities of all the loops. For example, if there are three nested loops, each running `n` times, the Big-O complexity would be O(n^3).\n\n```\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n        for (int k = 0; k < n; k++) {\n            // Some constant time operation\n        }\n    }\n}\n```\n\nIt's important to note that the Big-O complexity of nested loops can quickly become significant as the number of loops and iterations increases. Nested loops with high complexity can lead to performance issues, especially when dealing with large input sizes. In such cases, it's crucial to optimize the algorithm or consider alternative approaches to improve efficiency.",
    "expected_output": "Typically O(n^2) if both loops are linear over the same n.",
    "response_length": 2231,
    "word_count": 421,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953194"
  },
  {
    "sample_id": "cc_007",
    "protected_attributes": {},
    "input": "Outline steps to create a REST endpoint in Express.js.",
    "actual_output": "Here are the steps to create a REST endpoint in Express.js:\n\n1. Set up the Express.js project:\n   - Create a new directory for your project.\n   - Initialize a new Node.js project by running `npm init` in the project directory.\n   - Install Express.js by running `npm install express`.\n\n2. Create the Express.js application:\n   - Create a new file, e.g., `app.js`, and require the Express.js module.\n   - Create an instance of the Express application.\n   - Set up any necessary middleware, such as `express.json()` for parsing JSON request bodies.\n\n3. Define the REST endpoint:\n   - Choose the appropriate HTTP method (GET, POST, PUT, DELETE, etc.) based on the desired operation.\n   - Specify the endpoint URL path using the corresponding Express.js method (e.g., `app.get()`, `app.post()`, etc.).\n   - Define the route handler function that will be executed when the endpoint is accessed.\n\n4. Implement the route handler function:\n   - Access the request parameters, query parameters, or request body if needed.\n   - Perform any necessary data validation or authentication.\n   - Execute the desired operation or logic based on the endpoint's purpose.\n   - Send the appropriate response back to the client using methods like `res.send()`, `res.json()`, etc.\n\n5. Start the Express.js server:\n   - Specify the port number on which the server should listen.\n   - Start the server by calling `app.listen()` and providing the port number.\n\n6. Test the REST endpoint:\n   - Use tools like cURL, Postman, or a web browser to send requests to the endpoint.\n   - Verify that the endpoint responds correctly and returns the expected data.\n\nHere's a basic example of creating a GET endpoint in Express.js:\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Define the REST endpoint\napp.get('/api/hello', (req, res) => {\n  res.json({ message: 'Hello, World!' });\n});\n\n// Start the server\nconst port = 3000;\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nIn this example, a GET endpoint is defined at the URL path `/api/hello`. When accessed, it sends a JSON response with the message \"Hello, World!\". The server is started and listens on port 3000.\n\nRemember to handle errors appropriately, implement necessary security measures, and follow REST best practices while building your endpoints.",
    "expected_output": "Install express, define route, add middleware, start server.",
    "response_length": 2344,
    "word_count": 359,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953237"
  },
  {
    "sample_id": "cc_008",
    "protected_attributes": {},
    "input": "Show a JavaScript example of debouncing a resize event.",
    "actual_output": "Certainly! Here's an example of debouncing a resize event in JavaScript:\n\n```javascript\n// Debounce function\nfunction debounce(func, wait) {\n  let timeout;\n  return function () {\n    const context = this;\n    const args = arguments;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(context, args), wait);\n  };\n}\n\n// Function to handle the resize event\nfunction handleResize() {\n  console.log('Window resized!');\n  // Add your resize event handling logic here\n}\n\n// Debounced version of the handleResize function\nconst debouncedResize = debounce(handleResize, 250);\n\n// Attach the debounced function to the window's resize event\nwindow.addEventListener('resize', debouncedResize);\n```\n\nIn this example:\n\n1. We define a `debounce` function that takes a function (`func`) and a wait time (`wait`) as parameters. This function returns a new function that delays the execution of the original function until a specified amount of time has passed without any further invocations.\n\n2. Inside the `debounce` function, we use a `timeout` variable to keep track of the timer. Whenever the debounced function is called, it clears any previous timeout and sets a new timeout to call the original function after the specified wait time.\n\n3. We define a `handleResize` function that contains the logic to be executed when the window is resized. In this example, it simply logs a message to the console, but you can add your own resize event handling logic here.\n\n4. We create a debounced version of the `handleResize` function by calling the `debounce` function and passing the `handleResize` function and a wait time (in this case, 250 milliseconds). This means that the `handleResize` function will only be executed if there is a pause of at least 250 milliseconds between resize events.\n\n5. Finally, we attach the debounced function (`debouncedResize`) to the window's `resize` event using `addEventListener`.\n\nNow, whenever the window is resized, the `debouncedResize` function will be called. However, if multiple resize events occur within a short period of time, the `handleResize` function will only be executed once, after a pause of 250 milliseconds.\n\nDebouncing is useful for optimizing performance by preventing excessive or unnecessary function calls during rapid or frequent events like resizing or scrolling. It ensures that the function is only executed after a specified delay, allowing for a more efficient and responsive user experience.",
    "expected_output": "Use setTimeout/clearTimeout to delay handler calls.",
    "response_length": 2462,
    "word_count": 366,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953288"
  },
  {
    "sample_id": "cc_009",
    "protected_attributes": {},
    "input": "Explain what 'idempotent' means in HTTP methods.",
    "actual_output": "In the context of HTTP methods, idempotence refers to the property of certain HTTP methods that produce the same result when executed multiple times, assuming no other changes are made to the resource in between requests.\n\nHere's a more detailed explanation:\n\n1. Idempotent methods:\n   - GET: Retrieving a resource multiple times via GET should produce the same result each time, as long as the resource hasn't been modified.\n   - PUT: Updating a resource with the same data multiple times via PUT should have the same effect as updating it once. Subsequent identical requests should not change the resource's state.\n   - DELETE: Deleting a resource multiple times via DELETE should have the same outcome as deleting it once. If the resource doesn't exist, subsequent DELETE requests should still return a successful status code.\n   - HEAD: Similar to GET, but without the response body. Multiple HEAD requests should produce the same result.\n   - OPTIONS: Retrieving the available communication options for a resource multiple times should yield the same result.\n\n2. Non-idempotent methods:\n   - POST: Creating a new resource via POST multiple times will likely result in the creation of multiple separate resources. Each POST request is typically treated as a new, independent request.\n   - PATCH: Partially updating a resource via PATCH multiple times may result in different outcomes, depending on the specific changes made in each request.\n\nThe idempotence of HTTP methods is an important consideration when designing RESTful APIs. It helps in building robust and predictable APIs, as clients can safely retry idempotent requests without worrying about unintended side effects.\n\nHowever, it's important to note that the idempotence of a method depends on the server's implementation. It's the server's responsibility to ensure that the methods behave idempotently according to the HTTP specification.",
    "expected_output": "Multiple identical requests have the same effect as one.",
    "response_length": 1905,
    "word_count": 291,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953388"
  },
  {
    "sample_id": "cc_010",
    "protected_attributes": {},
    "input": "Provide a Python list comprehension example to flatten a 2D list.",
    "actual_output": "Certainly! Here's an example of using a list comprehension to flatten a 2D list in Python:\n\n```python\n# 2D list\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n# Flatten the 2D list using list comprehension\nflattened = [num for row in matrix for num in row]\n\nprint(flattened)\n```\n\nOutput:\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\nExplanation:\n- We have a 2D list called `matrix` that contains three sublists: `[1, 2, 3]`, `[4, 5, 6]`, and `[7, 8, 9]`.\n- The list comprehension `[num for row in matrix for num in row]` flattens the 2D list into a 1D list.\n- The outer loop `for row in matrix` iterates over each sublist in the `matrix`.\n- The inner loop `for num in row` iterates over each element within each sublist.\n- The expression `num` is used to collect each element from the sublists and create a new flattened list.\n- Finally, the flattened list is stored in the variable `flattened` and printed.\n\nThe resulting `flattened` list contains all the elements from the 2D list `matrix` in a single, flattened list: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`.\n\nThis list comprehension provides a concise and efficient way to flatten a 2D list into a 1D list in Python.",
    "expected_output": "[item for sub in arr for item in sub]",
    "response_length": 1149,
    "word_count": 217,
    "metric_scores": {},
    "timestamp": "2025-11-17T23:31:48.953414"
  }
]