sample_id,category,difficulty,word_count,response_length,actual_output,expected_output
cc_001,Unknown,Unknown,211,1262,"# Time Complexity of Binary Search

## Overview
Binary search has a time complexity of **O(log n)**, making it extremely efficient for searching sorted data.

## Why O(log n)?

### The Halving Process
With each comparison, binary search eliminates **half** of the remaining elements:

```
Initial array size: n
After 1st comparison: n/2
After 2nd comparison: n/4
After 3rd comparison: n/8
...
After k comparisons: n/2^k
```

### Mathematical Derivation
The search continues until we have 1 element left:
- n/2^k = 1
- n = 2^k
- **k = log₂(n)**

So we need at most **log₂(n)** comparisons.

## Concrete Example

For an array of **1,000,000 elements**:
- Linear search: up to 1,000,000 comparisons
- Binary search: at most **20 comparisons** (log₂(1,000,000) ≈ 20)

## Complexity Breakdown

| Case | Time Complexity | Description |
|------|----------------|-------------|
| **Best Case** | O(1) | Element found at middle on first try |
| **Average Case** | O(log n) | Element found somewhere in the middle |
| **Worst Case** | O(log n) | Element at end or not present |

## Space Complexity
- **Iterative**: O(1) - constant space
- **Recursive**: O(log n) - due to call stack

## Key Requirement
⚠️ **The array must be sorted** for binary search to work correctly!",Binary search runs in O(log n).
cc_002,Unknown,Unknown,484,4197,"# Stack Implementation in Python

Here are several ways to implement a stack with push and pop operations:

## 1. Using a List (Simplest)

```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """"""Add an item to the top of the stack""""""
        self.items.append(item)
    
    def pop(self):
        """"""Remove and return the top item from the stack""""""
        if self.is_empty():
            raise IndexError(""Pop from empty stack"")
        return self.items.pop()
    
    def peek(self):
        """"""Return the top item without removing it""""""
        if self.is_empty():
            raise IndexError(""Peek from empty stack"")
        return self.items[-1]
    
    def is_empty(self):
        """"""Check if the stack is empty""""""
        return len(self.items) == 0
    
    def size(self):
        """"""Return the number of items in the stack""""""
        return len(self.items)
    
    def __str__(self):
        return str(self.items)


# Example usage
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(f""Stack: {stack}"")  # Stack: [1, 2, 3]
print(f""Pop: {stack.pop()}"")  # Pop: 3
print(f""Peek: {stack.peek()}"")  # Peek: 2
print(f""Size: {stack.size()}"")  # Size: 2
```

## 2. Using collections.deque (More Efficient)

```python
from collections import deque

class Stack:
    def __init__(self):
        self.items = deque()
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if self.is_empty():
            raise IndexError(""Pop from empty stack"")
        return self.items.pop()
    
    def peek(self):
        if self.is_empty():
            raise IndexError(""Peek from empty stack"")
        return self.items[-1]
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)
```

## 3. Using a Linked List (Custom Implementation)

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class Stack:
    def __init__(self):
        self.top = None
        self._size = 0
    
    def push(self, item):
        """"""Add an item to the top of the stack""""""
        new_node = Node(item)
        new_node.next = self.top
        self.top = new_node
        self._size += 1
    
    def pop(self):
        """"""Remove and return the top item from the stack""""""
        if self.is_empty():
            raise IndexError(""Pop from empty stack"")
        popped_data = self.top.data
        self.top = self.top.next
        self._size -= 1
        return popped_data
    
    def peek(self):
        """"""Return the top item without removing it""""""
        if self.is_empty():
            raise IndexError(""Peek from empty stack"")
        return self.top.data
    
    def is_empty(self):
        """"""Check if the stack is empty""""""
        return self.top is None
    
    def size(self):
        """"""Return the number of items in the stack""""""
        return self._size
    
    def __str__(self):
        """"""String representation of the stack""""""
        items = []
        current = self.top
        while current:
            items.append(str(current.data))
            current = current.next
        return "" -> "".join(items) + "" -> None""


# Example usage
stack = Stack()
stack.push(10)
stack.push(20)
stack.push(30)
print(f""Stack: {stack}"")  # Stack: 30 -> 20 -> 10 -> None
print(f""Pop: {stack.pop()}"")  # Pop: 30
print(f""Peek: {stack.peek()}"")  # Peek: 20
```

## 4. Minimal Implementation (Just Push/Pop)

```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        return self.items.pop() if self.items else None


# Example usage
s = Stack()
s.push(1)
s.push(2)
print(s.pop())  # 2
print(s.pop())  # 1
```

## Comparison

| Implementation | Push | Pop | Best For |
|---------------|------|-----|----------|
| List | O(1)* | O(1) | Simple use cases |
| deque | O(1) | O(1) | Performance-critical |
| Linked List | O(1) | O(1) | Memory-sensitive |

*Amortized O(1) for list

The **list-based implementation** is recommended for most cases due to its simplicity and good performance!",Class with list backing and push/pop methods.
cc_003,Unknown,Unknown,234,1596,"# REST API

A **REST API** (Representational State Transfer Application Programming Interface) is a set of rules and conventions for building and interacting with web services. It's one of the most popular architectural styles for creating APIs that allow different software applications to communicate over the internet.

## Key Characteristics

**Stateless Communication**
- Each request from client to server must contain all information needed to understand and process the request
- The server doesn't store client context between requests

**Resource-Based**
- Everything is treated as a ""resource"" (users, products, posts, etc.)
- Each resource is identified by a unique URL (endpoint)
- Example: `https://api.example.com/users/123`

**Standard HTTP Methods**
- **GET** - Retrieve data
- **POST** - Create new data
- **PUT/PATCH** - Update existing data
- **DELETE** - Remove data

**Standard Data Formats**
- Typically uses JSON (sometimes XML) for data exchange
- Easy for both humans and machines to read

## Simple Example

```
GET https://api.store.com/products/456
Response: { ""id"": 456, ""name"": ""Laptop"", ""price"": 999 }

POST https://api.store.com/products
Body: { ""name"": ""Mouse"", ""price"": 25 }
```

## Why REST APIs Matter

- **Universal** - Works across different programming languages and platforms
- **Scalable** - Stateless nature makes it easy to scale
- **Simple** - Uses familiar HTTP protocols
- **Flexible** - Can serve multiple types of clients (web, mobile, IoT)

REST APIs power most modern web and mobile applications, enabling seamless data exchange between systems.",REST is an architectural style using HTTP verbs and resources.
cc_004,Unknown,Unknown,172,1292,"# Synchronous vs Asynchronous Code

## **Synchronous Code**
- Executes **line by line** in order
- Each operation must **complete before** the next one starts
- **Blocks** execution while waiting for operations to finish

```javascript
console.log(""First"");
console.log(""Second"");
console.log(""Third"");
// Output: First, Second, Third (in order)
```

## **Asynchronous Code**
- Allows operations to run **independently**
- Program continues executing without waiting for slow operations
- Uses **callbacks, promises, or async/await** to handle results later

```javascript
console.log(""First"");
setTimeout(() => console.log(""Second""), 1000);
console.log(""Third"");
// Output: First, Third, Second (Third doesn't wait)
```

## **Key Differences**

| Synchronous | Asynchronous |
|-------------|--------------|
| Blocking | Non-blocking |
| Predictable order | Order may vary |
| Simple to understand | More complex |
| Can freeze UI | Keeps UI responsive |

## **When to Use Each**

**Synchronous:** Simple calculations, data processing, sequential logic

**Asynchronous:** 
- Network requests (APIs)
- File operations
- Database queries
- Timers
- User interactions

Asynchronous code is essential for **responsive applications** that need to handle time-consuming operations without freezing.",Synchronous blocks execution; asynchronous allows other work while waiting.
cc_005,Unknown,Unknown,155,1057,"# SQL SELECT with WHERE and ORDER BY Example

Here's a practical example:

```sql
SELECT first_name, last_name, salary, hire_date
FROM employees
WHERE salary > 50000
ORDER BY salary DESC;
```

## Breakdown:

- **SELECT**: Retrieves `first_name`, `last_name`, `salary`, and `hire_date` columns
- **FROM**: Specifies the `employees` table
- **WHERE**: Filters to only include employees with salary greater than $50,000
- **ORDER BY**: Sorts results by salary in descending order (highest to lowest)

## Sample Result:

| first_name | last_name | salary | hire_date  |
|------------|-----------|--------|------------|
| John       | Smith     | 95000  | 2019-03-15 |
| Sarah      | Johnson   | 78000  | 2020-01-10 |
| Mike       | Davis     | 62000  | 2021-06-22 |

## Another Example (Multiple Conditions):

```sql
SELECT product_name, price, category
FROM products
WHERE category = 'Electronics' AND price < 500
ORDER BY price ASC, product_name ASC;
```

This filters for electronics under $500 and sorts by price (lowest first), then alphabetically by name.",SELECT name FROM users WHERE active = true ORDER BY created_at DESC;
cc_006,Unknown,Unknown,342,1848,"# Big-O for Nested Loops

## Basic Principle

When loops are nested, you typically **multiply** their complexities together.

## Common Patterns

### 1. **O(n²) - Two Dependent Loops**
```python
for i in range(n):      # runs n times
    for j in range(n):  # runs n times for each i
        print(i, j)     # O(1) operation
```
**Total: n × n = O(n²)**

### 2. **O(n × m) - Two Independent Loops**
```python
for i in range(n):      # runs n times
    for j in range(m):  # runs m times for each i
        print(i, j)
```
**Total: n × m = O(n × m)**

### 3. **O(n³) - Three Nested Loops**
```python
for i in range(n):
    for j in range(n):
        for k in range(n):
            print(i, j, k)
```
**Total: n × n × n = O(n³)**

### 4. **O(n) - Dependent Loop with Decreasing Iterations**
```python
for i in range(n):          # runs n times
    for j in range(i):      # runs 0, 1, 2, ..., n-1 times
        print(i, j)
```
**Total: 0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = O(n²)**

### 5. **O(n log n) - Outer Linear, Inner Logarithmic**
```python
for i in range(n):          # runs n times
    j = 1
    while j < n:            # runs log n times
        print(i, j)
        j *= 2
```
**Total: n × log n = O(n log n)**

### 6. **O(n) - Sequential (Not Nested!)**
```python
for i in range(n):
    print(i)

for j in range(n):  # This is AFTER the first loop
    print(j)
```
**Total: n + n = O(n)** *(add, don't multiply)*

## Quick Reference Table

| Pattern | Complexity | Example |
|---------|-----------|---------|
| Loop inside loop (both n) | O(n²) | Bubble sort |
| 3 nested loops | O(n³) | Matrix multiplication |
| Loop n, inner loop log n | O(n log n) | Some divide & conquer |
| Loop n, inner loop √n | O(n√n) | Some factorization |
| Two separate loops | O(n) | Just sequential |

## Key Takeaway

**Nested = Multiply, Sequential = Add**",Typically O(n^2) if both loops are linear over the same n.
cc_007,Unknown,Unknown,489,3577,"# Steps to Create a REST Endpoint in Express.js

## 1. **Set Up Your Project**
```bash
# Initialize a new Node.js project
npm init -y

# Install Express
npm install express
```

## 2. **Create the Basic Server File**
```javascript
// server.js or app.js
const express = require('express');
const app = express();
const PORT = 3000;

// Middleware to parse JSON
app.use(express.json());

// Start the server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## 3. **Define Your REST Endpoint**

### Basic GET Endpoint
```javascript
app.get('/api/users', (req, res) => {
  res.json({ message: 'Get all users' });
});
```

### GET with Parameters
```javascript
app.get('/api/users/:id', (req, res) => {
  const { id } = req.params;
  res.json({ message: `Get user ${id}` });
});
```

### POST Endpoint
```javascript
app.post('/api/users', (req, res) => {
  const userData = req.body;
  res.status(201).json({ message: 'User created', data: userData });
});
```

### PUT Endpoint
```javascript
app.put('/api/users/:id', (req, res) => {
  const { id } = req.params;
  const userData = req.body;
  res.json({ message: `User ${id} updated`, data: userData });
});
```

### DELETE Endpoint
```javascript
app.delete('/api/users/:id', (req, res) => {
  const { id } = req.params;
  res.json({ message: `User ${id} deleted` });
});
```

## 4. **Complete Example**
```javascript
const express = require('express');
const app = express();
const PORT = 3000;

// Middleware
app.use(express.json());

// Sample data
let users = [
  { id: 1, name: 'John Doe' },
  { id: 2, name: 'Jane Smith' }
];

// GET all users
app.get('/api/users', (req, res) => {
  res.json(users);
});

// GET single user
app.get('/api/users/:id', (req, res) => {
  const user = users.find(u => u.id === parseInt(req.params.id));
  if (!user) return res.status(404).json({ error: 'User not found' });
  res.json(user);
});

// POST new user
app.post('/api/users', (req, res) => {
  const newUser = {
    id: users.length + 1,
    name: req.body.name
  };
  users.push(newUser);
  res.status(201).json(newUser);
});

// PUT update user
app.put('/api/users/:id', (req, res) => {
  const user = users.find(u => u.id === parseInt(req.params.id));
  if (!user) return res.status(404).json({ error: 'User not found' });
  
  user.name = req.body.name;
  res.json(user);
});

// DELETE user
app.delete('/api/users/:id', (req, res) => {
  const index = users.findIndex(u => u.id === parseInt(req.params.id));
  if (index === -1) return res.status(404).json({ error: 'User not found' });
  
  users.splice(index, 1);
  res.status(204).send();
});

// Start server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```

## 5. **Run Your Server**
```bash
node server.js
```

## 6. **Test Your Endpoints**
```bash
# GET all users
curl http://localhost:3000/api/users

# GET single user
curl http://localhost:3000/api/users/1

# POST new user
curl -X POST http://localhost:3000/api/users \
  -H ""Content-Type: application/json"" \
  -d '{""name"":""New User""}'

# PUT update user
curl -X PUT http://localhost:3000/api/users/1 \
  -H ""Content-Type: application/json"" \
  -d '{""name"":""Updated Name""}'

# DELETE user
curl -X DELETE http://localhost:3000/api/users/1
```

## 7. **Best Practices**
- Use proper HTTP status codes (200, 201, 404, 500, etc.)
- Implement error handling middleware
- Validate request data
- Use environment variables for configuration
- Organize routes in separate files for larger applications
- Add authentication/authorization as needed","Install express, define route, add middleware, start server."
cc_008,Unknown,Unknown,372,3380,"# JavaScript Debouncing Example for Resize Event

Here's a practical example of debouncing a window resize event:

## Basic Implementation

```javascript
// Debounce function
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    // Clear the previous timeout
    clearTimeout(timeoutId);
    
    // Set a new timeout
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Your resize handler
function handleResize() {
  console.log('Window resized:', window.innerWidth, 'x', window.innerHeight);
  // Your resize logic here
}

// Add debounced event listener
window.addEventListener('resize', debounce(handleResize, 250));
```

## More Complete Example with Cleanup

```javascript
// Debounce function with immediate option
function debounce(func, delay, immediate = false) {
  let timeoutId;
  
  return function(...args) {
    const context = this;
    const later = () => {
      timeoutId = null;
      if (!immediate) func.apply(context, args);
    };
    
    const callNow = immediate && !timeoutId;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(later, delay);
    
    if (callNow) func.apply(context, args);
  };
}

// Resize handler
function handleResize() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  console.log(`Resized to: ${width}x${height}`);
  
  // Example: Update layout
  document.body.style.setProperty('--viewport-width', `${width}px`);
}

// Create debounced version
const debouncedResize = debounce(handleResize, 300);

// Add listener
window.addEventListener('resize', debouncedResize);

// Cleanup (important for SPAs)
// window.removeEventListener('resize', debouncedResize);
```

## Modern ES6 Class Example

```javascript
class ResizeHandler {
  constructor(delay = 250) {
    this.delay = delay;
    this.timeoutId = null;
    
    // Bind the debounced method
    this.debouncedResize = this.debounce(this.handleResize.bind(this));
    
    // Start listening
    this.init();
  }
  
  debounce(func) {
    return (...args) => {
      clearTimeout(this.timeoutId);
      this.timeoutId = setTimeout(() => func(...args), this.delay);
    };
  }
  
  handleResize() {
    console.log('Resize handled:', {
      width: window.innerWidth,
      height: window.innerHeight,
      timestamp: new Date().toISOString()
    });
  }
  
  init() {
    window.addEventListener('resize', this.debouncedResize);
  }
  
  destroy() {
    window.removeEventListener('resize', this.debouncedResize);
    clearTimeout(this.timeoutId);
  }
}

// Usage
const resizeHandler = new ResizeHandler(300);

// Later, when component unmounts:
// resizeHandler.destroy();
```

## Using Lodash (if available)

```javascript
import { debounce } from 'lodash';

const handleResize = () => {
  console.log('Window resized!');
};

window.addEventListener('resize', debounce(handleResize, 250));
```

## Key Points:

- **Delay**: 250-300ms is typically good for resize events
- **Cleanup**: Always remove listeners when components unmount (important in React, Vue, etc.)
- **Immediate option**: Execute function on the leading edge instead of trailing edge
- **Context preservation**: Use `apply()` to maintain proper `this` context

The debounce function ensures your handler only runs once after the user stops resizing, rather than hundreds of times during the resize!",Use setTimeout/clearTimeout to delay handler calls.
cc_009,Unknown,Unknown,259,1593,"# Idempotent HTTP Methods

## Definition

**Idempotent** means that making multiple identical requests has the same effect as making a single request. The server's state will be identical whether you execute the operation once or multiple times.

## Key Concept

```
Operation once = Operation N times (same result)
```

## Idempotent HTTP Methods

### ✅ Idempotent Methods

- **GET** - Reading data multiple times doesn't change anything
- **PUT** - Updating a resource to the same value multiple times results in the same state
- **DELETE** - Deleting something that's already deleted still results in it being deleted
- **HEAD** - Like GET, just retrieves headers
- **OPTIONS** - Requesting options multiple times doesn't change anything

### ❌ Non-Idempotent Methods

- **POST** - Each request typically creates a new resource or triggers a new action

## Practical Examples

### PUT (Idempotent)
```http
PUT /users/123
{ ""name"": ""John"", ""age"": 30 }

// Call this 1 time or 100 times → user 123 has same data
```

### DELETE (Idempotent)
```http
DELETE /users/123

// 1st call: deletes user 123
// 2nd call: user already gone (might return 404, but state is same)
```

### POST (Non-Idempotent)
```http
POST /orders
{ ""item"": ""book"", ""quantity"": 1 }

// Each call creates a NEW order
// 3 calls = 3 different orders
```

## Why It Matters

1. **Retry Safety** - Safe to automatically retry failed requests
2. **Network Reliability** - Handles duplicate requests from network issues
3. **Caching** - Helps determine caching strategies
4. **API Design** - Guides proper HTTP method selection",Multiple identical requests have the same effect as one.
cc_010,Unknown,Unknown,176,1168,"# Flatten a 2D list using list comprehension

# Example 2D list
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Flatten using list comprehension
flattened = [item for row in matrix for item in row]

print(""Original 2D list:"", matrix)
print(""Flattened list:"", flattened)
# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]

# More examples:

# Example with different sized sublists
irregular_matrix = [[1, 2], [3, 4, 5], [6]]
flattened_irregular = [item for row in irregular_matrix for item in row]
print(""\nIrregular matrix:"", irregular_matrix)
print(""Flattened:"", flattened_irregular)
# Output: [1, 2, 3, 4, 5, 6]

# Example with strings
words = [['hello', 'world'], ['python', 'list'], ['comprehension']]
flattened_words = [word for sublist in words for word in sublist]
print(""\n2D string list:"", words)
print(""Flattened:"", flattened_words)
# Output: ['hello', 'world', 'python', 'list', 'comprehension']

**Key Point:** The order in list comprehension reads left-to-right, like nested loops:
```python
# This list comprehension:
[item for row in matrix for item in row]

# Is equivalent to:
flattened = []
for row in matrix:
    for item in row:
        flattened.append(item)
```",[item for sub in arr for item in sub]
