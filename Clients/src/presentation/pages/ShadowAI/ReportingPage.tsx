/**
 * Shadow AI Reporting Page
 *
 * Main page for the Shadow AI reporting tab.
 * Shows a list of generated reports with filter, group, and search controls.
 * Follows the same pattern as /reporting (Reports page).
 */

import { useState, useCallback, useMemo } from "react";
import { Stack, Box } from "@mui/material";
import PageHeader from "../../components/Layout/PageHeader";
import { CustomizableButton } from "../../components/button/customizable-button";
import { EmptyState } from "../../components/EmptyState";
import { SearchBox } from "../../components/Search";
import { FilterBy, FilterColumn } from "../../components/Table/FilterBy";
import { GroupBy } from "../../components/Table/GroupBy";
import {
  useTableGrouping,
  useGroupByState,
} from "../../../application/hooks/useTableGrouping";
import { useFilterBy } from "../../../application/hooks/useFilterBy";
import { GroupedTableView } from "../../components/Table/GroupedTableView";
import ShadowAIReportTable from "./components/ShadowAIReportTable";
import GenerateShadowAIReport from "./components/GenerateShadowAIReport";
import { useIsAdmin } from "../../../application/hooks/useIsAdmin";
import { ShadowAIReportListItem } from "../../../application/repository/shadowAi.repository";
import TipBox from "../../components/TipBox";

export default function ReportingPage() {
  const [modalOpen, setModalOpen] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);
  const [reports, setReports] = useState<ShadowAIReportListItem[]>([]);
  const [hasReports, setHasReports] = useState<boolean | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const isAdmin = useIsAdmin();

  // GroupBy state
  const { groupBy, groupSortOrder, handleGroupChange } = useGroupByState();

  const handleReportGenerated = useCallback(() => {
    setRefreshKey((prev) => prev + 1);
  }, []);

  const handleReportsLoaded = useCallback(
    (count: number, data: ShadowAIReportListItem[]) => {
      setHasReports(count > 0);
      setReports(data);
    },
    []
  );

  // FilterBy - dynamic options
  const getUniqueFormats = useCallback(() => {
    const formats = new Set<string>();
    reports.forEach((r) => {
      const ext = r.filename?.endsWith(".pdf") ? "PDF" : "DOCX";
      formats.add(ext);
    });
    return Array.from(formats)
      .sort()
      .map((f) => ({ value: f, label: f }));
  }, [reports]);

  const getUniqueGenerators = useCallback(() => {
    const generators = new Set<string>();
    reports.forEach((r) => {
      const name = [r.uploader_name, r.uploader_surname]
        .filter(Boolean)
        .join(" ");
      if (name) generators.add(name);
    });
    return Array.from(generators)
      .sort()
      .map((g) => ({ value: g, label: g }));
  }, [reports]);

  // FilterBy - column config
  const filterColumns: FilterColumn[] = useMemo(
    () => [
      { id: "filename", label: "Report name", type: "text" as const },
      {
        id: "format",
        label: "Format",
        type: "select" as const,
        options: getUniqueFormats(),
      },
      {
        id: "generated_by",
        label: "Generated by",
        type: "select" as const,
        options: getUniqueGenerators(),
      },
      { id: "uploaded_time", label: "Date generated", type: "date" as const },
    ],
    [getUniqueFormats, getUniqueGenerators]
  );

  // FilterBy - field value getter
  const getFieldValue = useCallback(
    (
      item: ShadowAIReportListItem,
      fieldId: string
    ): string | number | Date | null | undefined => {
      switch (fieldId) {
        case "filename":
          return item.filename;
        case "format":
          return item.filename?.endsWith(".pdf") ? "PDF" : "DOCX";
        case "generated_by":
          return [item.uploader_name, item.uploader_surname]
            .filter(Boolean)
            .join(" ");
        case "uploaded_time":
          return item.uploaded_time;
        default:
          return null;
      }
    },
    []
  );

  const { filterData, handleFilterChange } =
    useFilterBy<ShadowAIReportListItem>(getFieldValue);

  // Apply filters + search
  const filteredReports = useMemo(() => {
    let result = filterData(reports);
    if (searchTerm.trim()) {
      const query = searchTerm.toLowerCase();
      result = result.filter((r) =>
        r.filename?.toLowerCase().includes(query)
      );
    }
    return result;
  }, [filterData, reports, searchTerm]);

  // GroupBy - key getter
  const getGroupKey = useCallback(
    (item: ShadowAIReportListItem, field: string): string => {
      switch (field) {
        case "format":
          return item.filename?.endsWith(".pdf") ? "PDF" : "DOCX";
        case "generated_by":
          return (
            [item.uploader_name, item.uploader_surname]
              .filter(Boolean)
              .join(" ") || "Unknown"
          );
        default:
          return "Other";
      }
    },
    []
  );

  const groupedReports = useTableGrouping({
    data: filteredReports,
    groupByField: groupBy,
    sortOrder: groupSortOrder,
    getGroupKey,
  });

  return (
    <Stack gap="16px">
      <PageHeader
        title="Reports"
        description="Generate and download Shadow AI reports."
      />
      <TipBox entityName="shadow-ai-reports" />

      {/* Toolbar: filter, group, search on left â€” generate button on right */}
      <Stack
        direction="row"
        justifyContent="space-between"
        alignItems="flex-end"
      >
        <Box sx={{ display: "flex", gap: "8px", alignItems: "center" }}>
          <FilterBy
            columns={filterColumns}
            onFilterChange={handleFilterChange}
          />
          <GroupBy
            options={[
              { id: "format", label: "Format" },
              { id: "generated_by", label: "Generated by" },
            ]}
            onGroupChange={handleGroupChange}
          />
          <SearchBox
            placeholder="Search reports..."
            value={searchTerm}
            onChange={setSearchTerm}
            fullWidth={false}
          />
        </Box>
        {isAdmin && (
          <CustomizableButton
            variant="contained"
            text="Generate report"
            onClick={() => setModalOpen(true)}
            sx={{
              height: "34px",
              backgroundColor: "#13715B",
              "&:hover": { backgroundColor: "#0F5A47" },
            }}
          />
        )}
      </Stack>

      {/* Report table with grouping support */}
      <GroupedTableView
        groupedData={groupedReports}
        ungroupedData={filteredReports}
        renderTable={(data) => (
          <ShadowAIReportTable
            refreshKey={refreshKey}
            onReportsLoaded={handleReportsLoaded}
            externalData={data}
          />
        )}
      />

      {hasReports === false && (
        <EmptyState
          message="No reports have been generated yet."
          showBorder
        />
      )}

      <GenerateShadowAIReport
        isOpen={modalOpen}
        onClose={() => setModalOpen(false)}
        onReportGenerated={handleReportGenerated}
      />
    </Stack>
  );
}
